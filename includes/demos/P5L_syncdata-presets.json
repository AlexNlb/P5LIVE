{
  "version": "1.2.7",
  "revision": 32,
  "structure": [
    {
      "name": "syncdata-presets",
      "type": "folder",
      "toggle": "expand",
      "contents": [
        {
          "name": "syncdata-template",
          "type": "sketch"
        },
        {
          "name": "syncdata-mouseXY",
          "type": "sketch"
        },
        {
          "name": "syncdata-midi",
          "type": "sketch"
        }
      ]
    }
  ],
  "sketches": [
    {
      "sketchName": "syncdata-template",
      "sketchCode": "/* syncData Preset : template\nUse 'sendData(obj)' in this window to send sync data.\nUse 'getData(obj)' in this window to receive sync data.\nUse 'parseData(obj)' in COCODING session to parse data.\nCheck 'obj.type', when syncing multiple types of data.\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (paste in COCODING session and uncomment)\n*/\n\n/* 0 - PREFS */\nlet userID = 0; // use unique ID for parsing getData later\n\n\n/* 1 - SYNC DATA */\n// let libs = ['']; // load external JS libraries\n\nlet obj = {\n\ttype: 'template',\n\tvalue: 'hello world',\n\tuser: userID\n};\nsendData(obj); // transmit to others\n\nfunction getData(obj) {\n\tif(obj.type && obj.type == 'template') {\n\t\tif(obj.user != userID) {\n\t\t\t// locally parse data sent from others\n\t\t\t// uniquely process compared to COCODING shared code\n\t\t}\n\t}\n}\n\n\n/* 2 - COCODE */\n// function parseData(obj) {\n// \t// parse only 'template' data\n// \tif(obj.type && obj.type == 'template') {\n// \t\tprint(obj);\n// \t\tgetData(obj);\n// \t}\n// }"
    },
    {
      "sketchName": "syncdata-mouseXY",
      "sketchCode": "/* syncData Preset : mouseXY\nSends your mouseX/mouseY + random color to all users.\nDraws each received signal as ellipse on demand.\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (paste in COCODING session and uncomment)\n*/\n\n/* 0 - PREFS */\nlet userID = 0; // use unique ID for parsing getData later\n\n\n/* 1 - SYNC DATA */\nlet delay = 0.05; // time in sec\nlet obj = {\n\ttype: 'mouseXY',\n\tuser: userID,\n\tx: 0,\n\ty: 0,\n\tcolor: '#' + Math.floor(Math.random() * 16777215).toString(16)\n};\n\nsetInterval(function() {\n\tsendMouse();\n}, delay * 1000);\n\nfunction sendMouse() {\n\tif(mouseX != obj.x && mouseY != obj.y) {\n\t\tobj.x = mouseX;\n\t\tobj.y = mouseY;\n\t\tsendData(obj); // transmit to others on change\n\t}\n}\n\n\n/* 2 - COCODE */\n// function parseData(obj) {\n// \t// parse only 'mouseXY' data\n// \tif(obj.type && obj.type === 'mouseXY') {\n// \t\tfill(obj.color);\n// \t\tellipse(obj.x, obj.y, 40);\n// \t\tfill(255);\n// \t\ttextSize(20);\n// \t\ttextAlign(CENTER, CENTER);\n// \t\ttext(obj.user, obj.x, obj.y);\n// \t}\n// }"
    },
    {
      "sketchName": "syncdata-midi",
      "sketchCode": "/* syncData Preset : midi\nTransmit midi notes/pitchbend/controlchanges to all users.\nCheck Javascript Console after running setup for device IDs + Names\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (copy + paste + uncomment in COCODING session)\n*/\n\n/* 0 - PREFS */\nlet midiUser = 0; // <-- give yourself unique ID for forwarding midi\nlet midiDeviceIn = 0; // [ID] or \"device name\"\nlet midiDeviceOut = 0; // [ID] or \"device name\"\nlet midiThru = false; // pass all midi data in -> out (except self)\n\n// debug latency\nlet localLatency = false; // true » check latency of own midi signal\nlet getLatency = false; // true » check latency of roundtrip (if peers sendLatency)\nlet sendLatency = false; // only peers should activate for sending back\n\n/* 1 - SYNC DATA */\nlet libs = [\"includes/js/webmidi.min.js\"];\nlet midiInput, midiOutput;\n\n// part of p5live.ccoding.js\nsetupMidi(midiDeviceIn, midiDeviceOut); // deviceIn, deviceOut\n\nfunction parseMidi(mm) {\n\tmm.type = 'midi'; // set syncData type\n\tmm.user = midiUser; // set unique person ID\n\tsendData(mm); // send to peers\n}\n\nfunction getData(obj) {\n\t// parse forwarded midiMessages from others to your local gear!\n\tif(obj.type && obj.type == 'midi') {\n\t\tif((obj.user != midiUser || midiDeviceIn != midiDeviceOut) && midiThru) {\n\t\t\tlet mm = obj;\n\t\t\t\n\t\t\t// debug local latency in ms\n\t\t\tif(localLatency){\n\t\t\t\tlet lag = new Date().getTime() - mm.start;\n\t\t\t\tprint(lag); \n\t\t\t}\n\t\t\t\n\t\t\t// peers sending signal back to origin for roundtrip debug\n\t\t\tif(sendLatency){\n\t\t\t\tlet pingpong = {\n\t\t\t\t\ttype: 'latency',\n\t\t\t\t\tstart: mm.start\n\t\t\t\t};\n\t\t\t\tsendData(pingpong);\n\t\t\t}\n\t\t\t\n\t\t\t// midiThru\n\t\t\tif(mm.data[2]) {\n\t\t\t\tmidiOutput.send(mm.data[0], [mm.data[1], mm.data[2]]);\n\t\t\t} else {\n\t\t\t\tmidiOutput.send(mm.data[0]);\n\t\t\t}\n\t\t}\n\t}else if(obj.type && obj.type == 'latency'){\n\t\t\n\t\t// debug roundtrip signal in ms\n\t\tif(getLatency){\n\t\t\tprintln(new Date().getTime() - obj.start); \n\t\t}\n\t}\n}\n\n\n/* 2 - COCODE */\n// function parseData(obj) {\n// \t// print(obj) // debug incoming message\n\n// \t// parse only 'midi' data\n// \tif(obj.type && obj.type == 'midi') {\n// \t\tlet mm = obj; // midimessage\n// \t\tif(mm.note !== undefined) {\n// \t\t\tswitch (mm.note.type) {\n// \t\t\t\tcase 'noteon':\n// \t\t\t\t\tnoteOn(mm.note);\n// \t\t\t\t\tbreak;\n// \t\t\t\tcase 'noteoff':\n// \t\t\t\t\tnoteOff(mm.note);\n// \t\t\t\t\tbreak;\n// \t\t\t}\n// \t\t} else if(mm.pitch !== undefined) {\n// \t\t\tpitchBend(mm.pitch);\n// \t\t} else if(mm.control !== undefined) {\n// \t\t\tcontrolChange(mm.contol);\n// \t\t}\n\n// \t\t// optionally listen to midiMessages from others on your local gear!\n// \t\tgetData(obj); // ignored by those without syncData active\n// \t}else if(obj.type && obj.type == 'latency'){\n// \t\tgetData(obj);\n// \t}\n// }\n\n// function noteOn(note) {\n// \t// use note.type, .channel, .name, .number, .octave, .velocity\n// \tlet x = map(note.number, 0, 128, 0, width);\n// \tlet h = map(note.velocity, 0, 128, 0, height);\n//\tbackground(0, 25);\n// \tpush();\n// \tnoStroke();\n// \tfill(note.velocity*2);\n// \trectMode(CENTER);\n// \trect(x, height/2, width/128, h);\n// \tpop();\n// }\n\n// function noteOff(note) {\n// \t// use note.type, .channel, .name, .number, .octave, .velocity\n// }\n\n// function pitchBend(pitch) {\n// \t// use pitch.type, .channel, .value\n// }\n\n// function controlChange(control) {\n// \t// use control.type, .channel, .controllerNumber, .controllerName, .value\n// }\n\n// function midiToFreq(noteNumber) {\n// \treturn 440 * Math.pow(2, (noteNumber - 69) / 12);\n// }"
    }
  ]
}