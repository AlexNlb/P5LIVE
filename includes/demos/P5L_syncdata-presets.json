{
  "version": "1.3.0",
  "revision": 33,
  "structure": [
    {
      "name": "syncdata-presets",
      "mod": "1587989594126",
      "type": "folder",
      "toggle": "expand",
      "contents": [
        {
          "name": "syncdata-template",
          "mod": "1587989594126",
          "type": "sketch",
          "parent": "syncdata-presets"
        },
        {
          "name": "syncdata-mouseXY",
          "mod": "1587989594126",
          "type": "sketch",
          "parent": "syncdata-presets"
        },
        {
          "name": "syncdata-facetracker",
          "mod": "1587989594126",
          "type": "sketch",
          "parent": "syncdata-presets"
        },
        {
          "name": "syncdata-midi",
          "mod": "1587989594126",
          "type": "sketch",
          "parent": "syncdata-presets"
        },
        {
          "name": "syncdata-gamepad",
          "mod": "1588081482981",
          "type": "sketch",
          "parent": "syncdata-presets"
        }
      ]
    }
  ],
  "sketches": [
    {
      "sketchName": "syncdata-template",
      "sketchCode": "/* syncData Preset : template\nUse 'sendData(obj)' here to sync local data.\nUse 'parseData(obj)' in COCODING to parse synced data.\nCall 'getData(obj)' in COCODING 'parseData(obj)' to handle locally.\nUse 'getData(obj)' here to parse synced data locally.\nCheck 'obj.type', when syncing multiple types of data.\nMade changes? Just press 'Re-Run' to update.\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (keep exact header below, ignored locally, add to COCODE)\n*/\n\n/* 0 - PREFS */\nlet userID = 0; // use unique ID per user to separate multiple syncs\n\n\n/* 1 - SYNC DATA */\n// let libs = ['']; // can load array of external JS libraries\n\nlet obj = {\n\ttype: 'template', // use type for parsing this vs other data\n\tvalue: 'hello world',\n\tuser: userID\n};\nsendData(obj); // transmit to others, use setInterval(function(){ }, 500) for pulse\n\nfunction getData(obj) {\n\tif(obj.type && obj.type == 'template') {\n\t\tif(obj.user != userID) { // (ignore own data)\n\t\t\t// locally parse data received from others\n\t\t\t// uniquely process compared to COCODING shared code\n\t\t}\n\t}\n}\n\n\n/* 2 - COCODE */\nfunction parseData(obj) {\n\t// parse only 'template' data\n\tif(obj.type && obj.type == 'template') {\n\t\tprint(obj);\n\t\tgetData(obj);\n\t}\n}",
      "mod": "1587989594126"
    },
    {
      "sketchName": "syncdata-mouseXY",
      "sketchCode": "/* syncData Preset : mouseXY\nSends your mouseX/mouseY + random color to all users.\nDraws each received signal as ellipse on demand.\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (add to COCODING session)\n*/\n\n/* 0 - PREFS */\nlet userID = 0; // use unique ID for parsing getData later\nlet delay = 0.05; // time in sec\n\n\n/* 1 - SYNC DATA */\nlet obj = {\n\ttype: 'mouseXY',\n\tuser: userID,\n\tx: 0,\n\ty: 0,\n\ts:40,\n\tcolor: '#' + Math.floor(Math.random() * 16777215).toString(16)\n};\n\nsetInterval(function() {\n\t// only update if mouse moved\n\tif(mouseX != obj.x && mouseY != obj.y) {\n\t\tobj.x = mouseX;\n\t\tobj.y = mouseY;\n\t\tsendData(obj); // send data to group!\n\t}\n}, delay * 1000);\n\n\n\n/* 2 - COCODE */\nfunction parseData(obj) {\n\t// parse only 'mouseXY' data\n\tif(obj.type && obj.type === 'mouseXY') {\n\t\tfill(obj.color);\n\t\tellipse(obj.x, obj.y, obj.s);\n\t\tfill(255);\n\t\ttextSize(obj.s/2);\n\t\ttextAlign(CENTER, CENTER);\n\t\ttext(obj.user, obj.x, obj.y);\n\t}\n}",
      "mod": "1587989594126"
    },
    {
      "sketchName": "syncdata-facetracker",
      "sketchCode": "/* syncData Preset : facetracker\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (add to COCODING session)\n*/\n\n/* 0 - PREFS */\nlet userID = 0; // use unique ID per user to separate multiple syncs\n\n\n/* 1 - SYNC DATA */\nlet libs = ['https://www.auduno.com/clmtrackr/build/clmtrackr.min.js']\nlet capture, tracker;\nlet obj = {\n\ttype: 'facetracker',\n\tid: userID,\n\tw: 320,\n\th: 240,\n\tscl: 1,\n\tcol: '#' + Math.floor(Math.random() * 16777215).toString(16),\n\tpositions: [],\n};\n\nsetupTracker();\n\nfunction setupTracker() {\n\tcapture = createCapture({\n\t\taudio: false,\n\t\tvideo: {\n\t\t\twidth: obj.w,\n\t\t\theight: obj.h\n\t\t}\n\t}, function() {\n\t\tconsole.log('capture ready.')\n\t});\n\tcapture.size(obj.w, obj.h);\n\tcapture.hide();\n\ttracker = new clm.tracker();\n\ttracker.init();\n\ttracker.start(capture.elt);\n\tobj.scl = width / obj.w;\n}\n\n// send regular pulse of positions\nsetInterval(function() {\n\tif(tracker) {\n\t\tobj.positions = tracker.getCurrentPosition();\n\t\tsendData(obj); // user data\n\t}\n}, 50);\n\n/* 2 - COCODE */\nlet data = {};\n\nfunction parseData(obj) {\n\t// parse only 'facetracker' data\n\tif(obj.type && obj.type == 'facetracker') {\n\t\tdata[obj.id] = obj;\n\t}\n}\n\n/* place following code in draw() \n\tbackground(0);\n\tnoStroke();\n\n\tfor (let [key, face] of Object.entries(data)) { \n\t\tfill(face.col);\n\t\tfor(let i = 0; i < face.positions.length; i++) {\n\t\t\tellipse(width - face.positions[i][0] * face.scl, face.positions[i][1] * face.scl, 10);\n\t\t}\n\t}\n*/",
      "mod": "1587989594126"
    },
    {
      "sketchName": "syncdata-midi",
      "sketchCode": "/* syncData Preset : midi\nTransmit midi notes/pitchbend/controlchanges to all users.\nCheck console below after pressing '► RUN' to learn device IDs + Names \n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (add to COCODING session)\n*/\n\n/* 0 - PREFS */\nlet midiUser = 0; // <-- give yourself unique ID for forwarding midi\nlet midiDeviceIn = 0; // [ID] or \"device name\"\nlet midiDeviceOut = 0; // [ID] or \"device name\"\nlet midiThru = false; // pass all midi data in -> out (except self)\n\n// debug latency\nlet localLatency = false; // true » check latency of own midi signal\nlet getLatency = false; // true » check latency of roundtrip (if peers sendLatency)\nlet sendLatency = false; // only peers should activate for sending back\n\n/* 1 - SYNC DATA */\nlet libs = [\"includes/js/webmidi.min.js\"];\nlet midiInput, midiOutput;\n\n// part of p5live.ccoding.js\nsetupMidi(midiDeviceIn, midiDeviceOut); // deviceIn, deviceOut\n\nfunction parseMidi(mm) {\n\tmm.type = 'midi'; // set syncData type\n\tmm.user = midiUser; // set unique person ID\n\tsendData(mm); // send to peers\n}\n\nfunction getData(obj) {\n\t// parse forwarded midiMessages from others to your local gear!\n\tif(obj.type && obj.type == 'midi') {\n\t\tif((obj.user != midiUser || midiDeviceIn != midiDeviceOut) && midiThru) {\n\t\t\tlet mm = obj;\n\n\t\t\t// debug local latency in ms\n\t\t\tif(localLatency) {\n\t\t\t\tlet lag = new Date().getTime() - mm.start;\n\t\t\t\tprint(lag);\n\t\t\t}\n\n\t\t\t// peers sending signal back to origin for roundtrip debug\n\t\t\tif(sendLatency) {\n\t\t\t\tlet pingpong = {\n\t\t\t\t\ttype: 'latency',\n\t\t\t\t\tstart: mm.start\n\t\t\t\t};\n\t\t\t\tsendData(pingpong);\n\t\t\t}\n\n\t\t\t// midiThru\n\t\t\tif(mm.data[2]) {\n\t\t\t\tmidiOutput.send(mm.data[0], [mm.data[1], mm.data[2]]);\n\t\t\t} else {\n\t\t\t\tmidiOutput.send(mm.data[0]);\n\t\t\t}\n\t\t}\n\t} else if(obj.type && obj.type == 'latency') {\n\n\t\t// debug roundtrip signal in ms\n\t\tif(getLatency) {\n\t\t\tprintln(new Date().getTime() - obj.start);\n\t\t}\n\t}\n}\n\n\n/* 2 - COCODE */\nlet midiMsg = {}; // check if props defined, useful in draw()\n\nfunction parseData(obj) {\n\t// print(obj) // debug incoming message\n\n\t// parse only 'midi' data\n\tif(obj.type && obj.type == 'midi') {\n\t\tlet mm = obj; // midimessage\n\t\tif(mm.note !== undefined) {\n\t\t\tswitch (mm.note.type) {\n\t\t\t\tcase 'noteon':\n\t\t\t\t\tnoteOn(mm.note);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'noteoff':\n\t\t\t\t\tnoteOff(mm.note);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if(mm.pitch !== undefined) {\n\t\t\tpitchBend(mm.pitch);\n\t\t} else if(mm.control !== undefined) {\n\t\t\tcontrolChange(mm.contol);\n\t\t}\n\n\t\t// global var for use in draw()\n\t\tmidiMsg = mm; // get latest message\n\n\t\t// optionally listen to midiMessages from others on your local gear!\n\t\tgetData(obj); // ignored by those without syncData active\n\t} else if(obj.type && obj.type == 'latency') {\n\t\tgetData(obj);\n\t}\n}\n\nfunction noteOn(note) {\n\t// use note.type, .channel, .name, .number, .octave, .velocity\n\tlet x = map(note.number, 0, 128, 0, width);\n\tlet h = map(note.velocity, 0, 128, 0, height);\n\tbackground(0, 25);\n\tpush();\n\tnoStroke();\n\tfill(note.velocity * 2);\n\trectMode(CENTER);\n\trect(x, height / 2, width / 128, h);\n\tpop();\n}\n\nfunction noteOff(note) {\n\t// use note.type, .channel, .name, .number, .octave, .velocity\n}\n\nfunction pitchBend(pitch) {\n\t// use pitch.type, .channel, .value\n}\n\nfunction controlChange(control) {\n\t// use control.type, .channel, .controllerNumber, .controllerName, .value\n}\n\nfunction midiToFreq(noteNumber) {\n\treturn 440 * Math.pow(2, (noteNumber - 69) / 12);\n}",
      "mod": "1587989594126"
    },
    {
      "sketchName": "syncdata-gamepad",
      "sketchCode": "/* syncData Preset : gamepad\nSends your gamepad data to all users.\nLearn from this game + COCODE your own with friends!\n\n0 - PREFS (unique local settings)\n1 - SYNC DATA (active in Sync Data)\n2 - COCODE (add to COCODING session)\n*/\n\n/* 0 - PREFS */\nlet userID = 0; // use unique ID for parsing getData later\nlet pollingDelay = 100; // time in millisec\n\n\n/* 1 - SYNC DATA */\nlet gp, gpInterval, gpMsg = {\n\t\taxes: [],\n\t\tbuttons: [],\n\t\ttimestamp: 0\n\t},\n\tpgpMsg = gpMsg;\n\n// gamepad connected - start polling\nwindow.addEventListener(\"gamepadconnected\", function() {\n\tgp = navigator.getGamepads()[0];\n\t//console.log(\"gamepad connected!\");\n\t//console.log(gp);\n\n\tclearInterval(gpInterval);\n\tgpInterval = setInterval(function() {\n\t\tgpUpdate();\n\t}, pollingDelay);\n});\n\n// gamepad disconnected - stop polling\nwindow.addEventListener(\"gamepaddisconnected\", function() {\n\tgp = undefined;\n\tclearInterval(gpInterval);\n});\n\nfunction gpUpdate() {\n\tif(gp !== undefined) {\n\t\tgp = navigator.getGamepads()[0];\n\t\tlet btns = [];\n\t\tfor(let b of gp.buttons) {\n\t\t\tbtns.push({\n\t\t\t\tpressed: b.pressed,\n\t\t\t\ttouched: b.touched,\n\t\t\t\tvalue: b.value\n\t\t\t})\n\t\t}\n\n\t\tgpMsg = {\n\t\t\ttype: 'gamepad',\n\t\t\tuser: userID,\n\t\t\taxes: gp.axes,\n\t\t\tbuttons: btns,\n\t\t\ttimestamp: gp.timestamp\n\t\t};\n\n\t\t// event happened if diff than previous\n\t\tif(JSON.stringify(gpMsg.buttons) != JSON.stringify(pgpMsg.buttons) || JSON.stringify(gpMsg.axes) != JSON.stringify(pgpMsg.axes)) {\n\t\t\tsendData(gpMsg); // send to group\n\t\t\tpgpMsg = gpMsg; // grab latest value\n\t\t}\n\t}\n}\n\n\n/* 2 - COCODE */\n\n/* Add to the draw()\n\tdrawGame();\n*/\n\nlet game = {\n\tspots: [],\n\tplayers: {},\n\tscore: [],\n\tborder: 15,\n\tgoal: 100,\n\tfield: 50,\n\tholder: -1,\n\twinner: -1\n};\n\nfunction parseData(obj) {\n\t// parse only 'gamepad' data\n\tif(obj.type && obj.type == 'gamepad') {\n\t\tif(game.players[obj.user] === undefined) {\n\t\t\t//console.log('new player!');\n\t\t\tgame.players[obj.user] = new Player(obj); // create player\n\t\t} else {\n\t\t\tgame.players[obj.user].gp = obj; // update player\n\t\t}\n\t}\n}\n\nfunction drawGame() {\n\tif(game.spots.length === 0) {\n\t\tcolorMode(HSB, 100);\n\t\tnewGame();\n\t}\n\n\tif(game.winner == -1) {\n\t\tbackground(game.field, 50, 20, 25);\n\t}\n\n\t// draw field\n\tpush();\n\tstroke(255);\n\tnoFill();\n\tlet pulse = 0;\n\tpush();\n\tif(game.holder != -1) {\n\t\tstroke(game.players[game.holder].color);\n\t\tpulse = 0.1;\n\t} else if(game.winner != -1) {\n\t\tstroke(game.players[game.winner].color);\n\t\tgame.goal += 20;\n\t}\n\tellipse(width / 2, height / 2, game.goal - abs(sin(frameCount * pulse)) * 5);\n\tpop();\n\trect(game.border, game.border, width - game.border * 2, height - game.border * 2);\n\tpop();\n\n\tfor(let [key, player] of Object.entries(game.players)) {\n\t\tplayer.update();\n\t}\n\n\tlet gameFinished = true;\n\tfor(let spot of game.spots) {\n\t\tdrawSpot(spot);\n\t\tif(spot.owner == -1) {\n\t\t\tgameFinished = false;\n\t\t}\n\t}\n\n\tif(gameFinished) {\n\t\tgame.winner = Math.max.apply(Math, game.spots.map(function(o) {\n\t\t\treturn o.owner;\n\t\t}));\n\t}\n}\n\nfunction drawSpot(spot) {\n\tpush();\n\tstroke(spot.color);\n\tfill(spot.color);\n\tif(game.winner != -1) {\n\t\tnoFill();\n\t\tstrokeWeight(0.125);\n\t}\n\tif(spot.owner === -1) {\n\t\tif(spot.x > game.border && spot.x < width - game.border) {\n\t\t\tspot.x += random(-spot.v, spot.v);\n\t\t}\n\t\tif(spot.y > game.border && spot.y < height - game.border) {\n\t\t\tspot.y += random(-spot.v, spot.v);\n\t\t}\n\t}\n\tellipse(spot.x, spot.y, game.goal / 4);\n\tpop();\n}\n\nfunction newGame() {\n\tgame.spots = [];\n\tfor(let i = 0; i < 10; i++) {\n\t\tlet spot = {};\n\t\tspot.id = i;\n\t\tspot.x = random(game.border * 4, width - game.border * 4);\n\t\tspot.y = random(game.border * 4, height - game.border * 4);\n\t\tif(dist(spot.x, spot.y, width / 2, height / 2) < game.goal) {\n\t\t\tspot.x += game.goal * 2;\n\t\t\tspot.y += game.goal * 2;\n\t\t}\n\t\tspot.v = random(0.01, 2);\n\t\tspot.color = color(255);\n\t\tspot.owner = -1;\n\t\tgame.spots.push(spot);\n\t}\n\tgame.field = random(100);\n\tgame.winner = -1;\n\tgame.holder = -1;\n\tgame.goal = random(50, 150);\n\tfor(let [key, player] of Object.entries(game.players)) {\n\t\tplayer.pos.z = game.goal / 2;\n\t\tplayer.vel = game.goal / 100;\n\t}\n}\n\n\n\nclass Player {\n\tconstructor(obj) {\n\t\tthis.gp = obj;\n\t\tthis.user = obj.user;\n\t\tthis.pos = createVector(width / 2, height / 2, game.goal / 2);\n\t\tthis.dir = createVector(0, 0, 0);\n\t\tthis.vel = game.goal / 100;\n\t\tthis.shapeMode = 0;\n\t\tthis.grab = -1;\n\t\tthis.hold = -1;\n\t\tthis.sw = 1;\n\t\tthis.color = color(random(100), 100, 100);\n\t}\n\n\tupdate() {\n\t\tif(this.gp !== undefined) {\n\t\t\tthis.axesUpdate();\n\t\t\tthis.buttonsUpdate();\n\t\t}\n\t\tthis.display();\n\n\t}\n\n\taxesUpdate() {\n\t\t// horizontal dpad axis\n\t\tif(this.gp.axes[0] == 1 || this.gp.axes[0] == -1) {\n\t\t\tthis.dir.x += this.gp.axes[0] / 10;\n\t\t}\n\n\t\tthis.pos.x += this.dir.x * this.vel;\n\t\tif(this.pos.x > width + this.pos.z / 2) {\n\t\t\tthis.pos.x = -this.pos.z / 2;\n\t\t} else if(this.pos.x < -this.pos.z / 2) {\n\t\t\tthis.pos.x = width + this.pos.z / 2;\n\t\t}\n\n\t\t// vertical dpad axis\n\t\tif(this.gp.axes[1] == 1 || this.gp.axes[1] == -1) {\n\t\t\tthis.dir.y += this.gp.axes[1] / 10;\n\t\t}\n\n\t\tthis.pos.y += this.dir.y * this.vel;\n\t\tif(this.pos.y > height + this.pos.z / 2) {\n\t\t\tthis.pos.y = -this.pos.z / 2;\n\t\t} else if(this.pos.y < -this.pos.z / 2) {\n\t\t\tthis.pos.y = height + this.pos.z / 2;\n\t\t}\n\t}\n\n\tbuttonsUpdate() {\n\t\tfor(let i = 0; i < this.gp.buttons.length; i++) {\n\t\t\tif(this.gp.buttons[i].pressed) {\n\n\t\t\t\tif(this.hold === -1 && this.grab == -1) {\n\t\t\t\t\tthis.grab = i;\n\t\t\t\t\tfor(let sp of game.spots) {\n\t\t\t\t\t\tif(dist(this.pos.x, this.pos.y, sp.x, sp.y) < this.pos.z / 2 && sp.owner == -1) {\n\t\t\t\t\t\t\tthis.hold = sp.id;\n\t\t\t\t\t\t\tgame.holder = this.user;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(this.grab === i) {\n\t\t\t\t\tthis.grab = -1;\n\t\t\t\t\tgame.holder = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// drop\n\t\tif(this.hold != -1 && this.grab == -1) {\n\t\t\tlet sp = game.spots[this.hold];\n\n\t\t\t// on target\n\t\t\tif(dist(width / 2, height / 2, sp.x, sp.y) < game.goal / 2) {\n\t\t\t\tsp.color = this.color;\n\t\t\t\tsp.owner = this.user;\n\t\t\t}\n\t\t\tthis.hold = -1;\n\t\t}\n\n\n\t\t// start + select\n\t\tif(this.gp.buttons[9].pressed) {\n\t\t\tthis.dir = createVector(0, 0, 0);\n\t\t} else if(this.gp.buttons[8].pressed) {\n\t\t\tnewGame();\n\t\t}\n\t}\n\n\tdisplay() {\n\t\tlet x = this.pos.x;\n\t\tlet y = this.pos.y;\n\t\tlet z = this.pos.z;\n\t\tpush();\n\t\tnoFill();\n\t\tstroke(this.color);\n\t\tif(this.grab != -1) {\n\t\t\tfill(this.color);\n\t\t\tif(this.hold != -1) {\n\t\t\t\tlet sp = game.spots[this.hold];\n\t\t\t\tsp.x = x;\n\t\t\t\tsp.y = y;\n\t\t\t}\n\t\t}\n\t\tstrokeWeight(this.sw);\n\t\trectMode(CENTER);\n\t\tellipse(x, y, z);\n\t\tpop();\n\t}\n}",
      "mod": "1588081482981"
    }
  ]
}